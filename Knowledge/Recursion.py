"""Recursion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qNz4G7N9AlTKIiWLYyIa-xihLDCcHqdE

**What is Recursion:** A way to solve a problem by having a function calling itself.
-Performing the same operation multiple times with different inputs.
-In every step we try smallers inputs to make the problem smaller.

**Why we need Recurwsion:** Recursion thinkin is really important in programming and it helps break down big problems into smaller ones and easier to use
The prominnent usage of reursion in data structures like trees and graphs
IT is usaed in many algorithms

**Recursive vs Iterative Solutions:**

## Examples

### Fibonacci
"""

# Fibonacci Numbers: Is a sequence of Numbers in which each number is the sum of the proceding ones and teh sequence starts from 0 and 1
def fibonacci(n):
    assert n >= 0 and int(n) == n, "Fibonachi number can't be negative number or a non integer"
    if n in [0,1]:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)
print(fibonacci(9))

"""### Sum of List using Recursion
Implement a function which takes a list as a parameter and calculates the sum of a list of numbers.

**Input:** sum_list([1, 2, 3, 4, 5])

**Output:**
15
"""

def sum_list(p_list):
    if not isinstance(p_list, list):
        return -1
    if len(p_list) == 1:
        return p_list[0]
    else:
        return p_list[0] + sum_list(p_list[1:])
print(sum_list([1,2,3,4,5]))

def sum_list_optimized(l):
    if l == []:
        return 0
    return l[0] + sum_list(l[1:])
print(sum_list_optimized([1,2,3,4,5]))

"""### **'a' to the power 'b' - using Recursion**
Implement a function to calculate the value of 'a' to the power 'b' using Recursion for positive integer numbers.

**Example:**
power(2,4)

**Output:**
16
"""

# My Solution:
def power(a,b):
    assert b >= 0 and int(b) == b, "The power must be a positive integer number"
    if b == 0:
        return 1
    else:
        return a * power(a,b-1)
power(2,4)

# Program Solution:
def power_optimized(a,b):
    if not isinstance(a, int) or not isinstance(b, int)  or b < 0:
        return "Not Applicable"
    elif b == 0:
        return 1
    elif b == 1:
        return a
    else:
        return a * power_optimized(a,b-1)

"""### Sum of Positive Integers
Implement a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).

**Example:**
sum_positive(10)

**Output:** 30
"""

# My Solution:
def sum_positive(n):
    assert n >= 0 and int(n) == n, "The number must be a positive integer number"
    assert n % 2 == 0, "The number must be an even number"
    if n == 0:
        return 0
    else:
        return n + sum_positive(n-2)
sum_positive(10)

# Program Solution: